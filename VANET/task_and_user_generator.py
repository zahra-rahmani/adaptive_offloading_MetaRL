import random
import xml.etree.ElementTree as Et
from collections import defaultdict

from dataclasses import dataclass
from xml.dom import minidom


class Config:
    SIMULATION_MAX = 1199

    class TaskConfig:
        """Represents the whole configuration for each task."""

        MIN_EXEC_TIME: float = 1.0
        MAX_EXEC_TIME: float = 3.0

        MIN_POWER_CONSUMPTION: float = 1.0
        MAX_POWER_CONSUMPTION: float = 3.0

        DEADLINE_MIN_FREE_TIME: float = 0.0
        DEADLINE_MAX_FREE_TIME: float = 5.0

    class VehicleConfig:
        """Represents the configuration for our mobile fog nodes."""
        # The rate at which tasks are generated by mobile fog nodes at a normal situation.
        TASK_GENERATION_RATE: float = 0.5

        # The rate at which tasks are generated by mobile fog nodes at a fucked up situation.
        FUCKED_UP_TASK_GENERATION_RATE: float = 0.8

        TRAFFIC_MIN_SPEED_THRESHOLD: float = 3.5

        LANE_TRAFFIC_THRESHOLD: int = 20

        MAX_COMPUTATION_POWER: float = 5.0  # The Max computation power that a user has itself.
        MIN_COMPUTATION_POWER: float = 2.0  # The Min computation power that a user has itself.

        COMPUTATION_POWER_ROUND_DIGIT: int = 2  # The number of decimal digit to round in computation power.

    class MobileFogConfig:
        MAX_COMPUTATION_POWER: float = 8.0  # The Max computation power that a zone has itself.
        MIN_COMPUTATION_POWER: float = 5.0  # The Min computation power that a zone has itself.

        COMPUTATION_POWER_ROUND_DIGIT: int = 2  # The number of decimal digit to round in computation power.


@dataclass
class Vehicle:
    """Represents a mobile fog node in the network with a unique identifier and spatial coordinates."""

    id: str
    x: float
    y: float
    angle: float
    speed: float
    power: float
    type: str
    lane: str


@dataclass
class Task:
    id: str
    deadline: float
    exec_time: float  # The amount of time that this task required to execute.
    power: float  # The amount of power unit that this tasks consumes while executing.
    creator: str  # Thd id of the node who created the task.


class Generator:
    def __init__(self):
        self.vehicles_nod_data_in_time: dict[float, list[Vehicle]] = defaultdict(list)
        self.tasks_data_in_time: dict[float, list[Task]] = defaultdict(list)

    @staticmethod
    def generate_one_step_task(step, vehicle, lane_counter):
        """Generate tasks for each mobile fog node."""
        exec_time = round(
            random.uniform(
                Config.TaskConfig.MIN_EXEC_TIME,
                Config.TaskConfig.MAX_EXEC_TIME,
            ),
            2
        )
        deadline_free = round(
            random.uniform(
                Config.TaskConfig.DEADLINE_MIN_FREE_TIME,
                Config.TaskConfig.DEADLINE_MAX_FREE_TIME,
            ),
            2
        )
        deadline = round(exec_time + deadline_free) + step
        power = round(
            random.uniform(
                Config.TaskConfig.MIN_POWER_CONSUMPTION,
                Config.TaskConfig.MAX_POWER_CONSUMPTION
            ),
            2
        )
        chance = random.random()
        threshold = Config.VehicleConfig.TASK_GENERATION_RATE
        if (
                lane_counter > Config.VehicleConfig.LANE_TRAFFIC_THRESHOLD or
                vehicle.speed < Config.VehicleConfig.TRAFFIC_MIN_SPEED_THRESHOLD
        ):
            threshold = Config.VehicleConfig.FUCKED_UP_TASK_GENERATION_RATE
        if chance > threshold:
            return None
        elif deadline >= Config.SIMULATION_MAX:
            return None
        return Task(
            id=f"{vehicle.id}_{step}",
            deadline=deadline,
            exec_time=exec_time,
            power=power,
            creator=vehicle.id
        )

    def generate_one_step(self, step, time_data, seen_ids_power):
        """Generate vehicles for each mobile fog node."""
        lane_counter: dict[str, int] = defaultdict(int)
        for vehicle in time_data.findall('vehicle'):
            v_id = vehicle.get('id')
            data = dict(
                id=v_id,
                x=float(vehicle.get('x')),
                y=float(vehicle.get('y')),
                angle=90 - float(vehicle.get('angle')),  # This is a tof because SUMO is stupid!
                speed=float(vehicle.get('speed')),
                lane=vehicle.get('lane'),
                type=vehicle.get('type')
            )

            if v_id in seen_ids_power:
                power = seen_ids_power[v_id]
            elif vehicle.get('type') == "LKW_special":  # Fog Nodes.
                power = round(
                    random.uniform(
                        Config.MobileFogConfig.MIN_COMPUTATION_POWER,
                        Config.MobileFogConfig.MAX_COMPUTATION_POWER
                    ),
                    Config.MobileFogConfig.COMPUTATION_POWER_ROUND_DIGIT
                )
            elif vehicle.get('type') == "PKW_special":  # User nodes
                power = round(
                    random.uniform(
                        Config.VehicleConfig.MIN_COMPUTATION_POWER,
                        Config.VehicleConfig.MAX_COMPUTATION_POWER
                    ),
                    Config.MobileFogConfig.COMPUTATION_POWER_ROUND_DIGIT
                )
            else:
                continue
            seen_ids_power[v_id] = power
            data["power"] = power
            vehicle_obj = Vehicle(**data)
            self.vehicles_nod_data_in_time[step].append(vehicle_obj)
            lane_counter[vehicle_obj.lane] += 1

            if task := self.generate_one_step_task(step, vehicle_obj, lane_counter[vehicle_obj.lane]):
                self.tasks_data_in_time[step].append(task)
        return seen_ids_power

    def generate_data(self, path: str):
        """Parse the time data from the given content."""
        with open(path, 'rb') as f:
            root = Et.parse(f).getroot()
        seen_ids_power = {}
        for time in root.findall('.//timestep'):
            step = float(time.get('time'))
            seen_ids_power = self.generate_one_step(step, time, seen_ids_power)

    def save_vehicles_to_xml(self, v_file):
        root = Et.Element('fcd-export')
        root.set("version", "1.0")
        for time, vehicles in self.vehicles_nod_data_in_time.items():
            time_elem = Et.SubElement(root, 'timestep')
            time_elem.set('time', f"{time:.2f}")
            for vehicle in vehicles:
                v_elem = Et.SubElement(time_elem, 'vehicle')
                v_elem.set('id', vehicle.id)
                v_elem.set('x', f"{vehicle.x:.2f}")
                v_elem.set('y', f"{vehicle.y:.2f}")
                v_elem.set('angle', f"{vehicle.angle:.2f}")
                v_elem.set('speed', f"{vehicle.speed:.2f}")
                v_elem.set('lane', vehicle.lane)
                v_elem.set('type', vehicle.type)
                v_elem.set('power', f"{vehicle.power:.2f}")

        xml_str = minidom.parseString(Et.tostring(root)).toprettyxml(indent="    ")
        with open(v_file, 'w', encoding='utf-8') as f:
            f.write(xml_str)

    def save_tasks_to_xml(self, t_file):
        root = Et.Element('fcd-export')
        root.set("version", "1.0")
        for time, tasks in self.tasks_data_in_time.items():
            time_elem = Et.SubElement(root, 'timestep')
            time_elem.set('time', f"{time:.2f}")
            for task in tasks:
                t_elem = Et.SubElement(time_elem, 'task')
                t_elem.set('id', task.id)
                t_elem.set('deadline', f"{task.deadline:.2f}")
                t_elem.set('exec_time', f"{task.exec_time:.2f}")
                t_elem.set('power', f"{task.power:.2f}")
                t_elem.set('creator', task.creator)

        xml_str = minidom.parseString(Et.tostring(root)).toprettyxml(indent="    ")
        with open(t_file, 'w', encoding='utf-8') as f:
            f.write(xml_str)


def main(path: str):
    """Main function to run the task generator."""
    generator = Generator()
    generator.generate_data(path)
    generator.save_vehicles_to_xml("./data/hamburg.out.xml")
    generator.save_tasks_to_xml("./data/hamburg.tasks.xml")


if __name__ == '__main__':
    main("./simulation.out.xml")
